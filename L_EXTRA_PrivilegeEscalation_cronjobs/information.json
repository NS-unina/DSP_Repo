{"description":"Privilege Escalation using scheduled cronjobs","goal":"<p>Explore various methods to escalate privileges on a linux machine using scheduled cronjobs</p>\n<p>This Lab was modeled after the following article:&nbsp;<a href=\"https://www.hackingarticles.in/linux-privilege-escalation-by-exploiting-cron-jobs/\">https://www.hackingarticles.in/linux-privilege-escalation-by-exploiting-cron-jobs/</a></p>","solution":"<p>First off, if you do not already have it, go ahead and grab our lightweight ssh client hack tool. <br />In a terminal on your host, type:</p>\n<p style=\"padding-left: 30px;\">$ docker pull nsunina/alpine_ssh:latest</p>\n<p>&nbsp;</p>\n<p>Start the lab and follow the standard procedure to attach an interactive hack tool. This will allow you to interact with the vulnerable environment.</p>\n<p>Create a new interactive service in the Hack Tool tab: name it \"ssh_client\", select \"nsunina/alpine_ssh:latest\" as base docker image and run it.</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/1.png\" alt=\"\" width=\"1367\" height=\"626\" /></p>\n<p>As soon as the container is up and running, attach it to the target network:</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/2.png\" alt=\"\" width=\"425\" height=\"123\" /></p>\n<p>Then, access the web shell.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/3.png\" alt=\"\" width=\"277\" height=\"112\" /></p>\n<p>Connect to the vulnerable container via SSH as an unprivileged user. In reality, you will have to compromise the target machine and get remote access, before applying any of the following techniques.</p>\n<p style=\"padding-left: 30px;\">$ ssh <a href=\"mailto:user1@193.20.1.2\">user1@193.20.1.2</a></p>\n<p>The password is \"pass123\".</p>\n<h3>&nbsp;Linux Cron Jobs</h3>\n<dl>\n<dt><em>cron</em> is a time-based job scheduler in Unix-like computer operating systems. It allows users to schedule jobs (commands or shell scripts) to run periodically at certain times, dates or intervals. Automation of maintenance or administration tasks usually relies on the use of cron jobs.</dt>\n</dl>\n<h3>Crontab Format</h3>\n<p>The basic format for a crontab (a file used by cron located under /etc) is:</p>\n<p style=\"padding-left: 30px;\"><em>minute</em> <em>hour</em> <em>day_of_month</em> <em>month</em> <em>day_of_week</em> <em>command</em></p>\n<p>where you can specify the periodicity of the command to be executed.</p>\n<p>Moreover, some special characters can be used to refine the time schedule according to users' need:</p>\n<ul>\n<li>Asterisk (*) is a wildcard that specifies any possible time interval</li>\n<li>Multiple values can be separated by a comma character (,)</li>\n<li>A range between patterns can be specified using a hyphen character (-)</li>\n<li>Frequency/periodicity can be indicated with a slash character (/)</li>\n</ul>\n<p>For example,</p>\n<ul>\n<li>\n<pre>0 */2 * * * echo \"How are you?\"</pre>\n</li>\n</ul>\n<p>will echo the string \"How are you\", every two hours,</p>\n<p>or,</p>\n<ul>\n<li>\n<pre>*/15 9-17 * * 2-5 ping google.com </pre>\n</li>\n</ul>\n<p>will ping google.com every 15 minutes from 9am-5pm on weekdays.</p>\n<h3>Privilege Escalation</h3>\n<p>Let's have a look at the crontab file in our target machine.</p>\n<p style=\"padding-left: 30px;\">$ cat /etc/crontab</p>\n<p>&nbsp;<img src=\"https://i.imgur.com/mgZ5THi.png\" alt=\"\" width=\"952\" height=\"324\" /></p>\n<p>We immediately notice two unusual jobs:</p>\n<ul>\n<li>/tmp/cleanup.py, run as root every 2 minutes, every day;</li>\n<li>a tar command, run as root every minute, every day.</li>\n</ul>\n<p>Starting with the first one, let's go have a look at the content of the file.</p>\n<p style=\"padding-left: 30px;\">$ cat /tmp/cleanup.py</p>\n<p><img src=\"https://i.imgur.com/WeslVA4.png\" alt=\"\" width=\"389\" height=\"146\" /></p>\n<p>It seems to perform a full cleanup of the /home/cleanup directory...nothing particularly harmful.</p>\n<p>However, we must remember that, every two minutes, this script is executed as root, thanks to the cron scheduler.</p>\n<p>Let's have a look at the file permissions.</p>\n<p style=\"padding-left: 30px;\">$ ls -la /tmp</p>\n<p><img src=\"https://i.imgur.com/Ar3hKeN.png\" alt=\"\" width=\"472\" height=\"93\" /></p>\n<p>As you can see, the file is editable by everyone. It is almost too easy!</p>\n<p>Let's edit it using nano.</p>\n<p style=\"padding-left: 30px;\">$ nano /tmp/cleanup.py</p>\n<p>Of course at this point we can force this script to make pretty much anything we want. Remember that it will be run by root, thanks to the cron scheduling mechanism.</p>\n<p>For instance, we can modify the system command to give suid permission to a shell, such as /bin/bash.</p>\n<p><img src=\"https://i.imgur.com/azCz5Di.png\" alt=\"\" width=\"381\" height=\"169\" /></p>\n<p>Save it and wait a couple of minutes, until cron will execute the script again.</p>\n<p>After a couple of minutes, we can check out whether our trick worked, looking for the files in the system with the SUID bit active.</p>\n<p style=\"padding-left: 30px;\">$ find / -perm -u=s -type f 2&gt;/dev/null</p>\n<p><img src=\"https://i.imgur.com/bubeDuH.png\" alt=\"\" width=\"548\" height=\"235\" /></p>\n<p>As you can see, now \"/bin/bash\" is among the list of files that a normal user can run with root privileges.</p>\n<p style=\"padding-left: 30px;\">&nbsp;$ /bin/bash -p</p>\n<p><img src=\"https://i.imgur.com/PO0aiyl.png\" alt=\"\" width=\"319\" height=\"56\" /></p>\n<h4>Tar Wildcard Injection</h4>\n<p>Now we will try out another technique, called Tar wildcard injection.</p>\n<p>Let's go back to our crontab file.</p>\n<p><img src=\"https://i.imgur.com/mgZ5THi.png\" alt=\"\" width=\"952\" height=\"324\" /></p>\n<p>The last entry in the table is a task that seems to create an archive out of the content of the /var/www/html directory every minute. This simulates a situation where cron is used to schedule a regular backup of a hosted website.</p>\n<p>The problem with this command, is the use of the wildcard \"*\", which is supposed to take everything inside the folder and pass it to the tar command, in order to create the archive.</p>\n<p>If we take a look at the tar command help, we can see two interesting options.</p>\n<p style=\"padding-left: 30px;\">$ tar --help</p>\n<p><img src=\"https://i.imgur.com/Mkij6rT.png\" alt=\"\" width=\"696\" height=\"94\" /></p>\n<p>Thanks to the checkpoint options, we could tell tar to display some log output every NUMBERth record and then execute an action.</p>\n<p>As you can imagine, we want tar to execute an ad hoc script written by us.</p>\n<p>But how can we pass it to tar, if the command executed by cron does not already incluse such options?</p>\n<p>We will abuse the \"*\" wildcard!</p>\n<p>In fact, we will create some fake files inside the /var/www/html directory. The name of these files will be exactly like the options we want to pass tar. <br />When the command will be executed, because of the \"*\" wildcard which grabs everything in that folder, tar will interpret our \"fake\" files as options.</p>\n<p>Let's first write a script where we grant root permissions to our current users, modifying the /etc/sudoers file. Remember to do this inside the /var/www/html directory.</p>\n<p style=\"padding-left: 30px;\">$ echo 'echo \"user1 ALL=(root) NOPASSWD: ALL\" &gt; /etc/sudoers' &gt; privesc.sh</p>\n<p>The first echo is to write the privesc.sh file; the second echo is what we want root to do, when the command is executed by cron. If this syntax looks confusing, you can always use an text editor, such as nano.</p>\n<p>Now that we have our nasty script, let's create two fake files with the names of the options we want to pass to tar.</p>\n<p style=\"padding-left: 30px;\">$ echo \"\" &gt; \"--checkpoint-action=exec=sh privesc.sh\"</p>\n<p style=\"padding-left: 30px;\">$ echo \"\" &gt; --checkpoint=1</p>\n<p>With these two options we tell tar to execute our script whenever a new record is compressed.</p>\n<p>Now, if everything works out correctly, every minute, cron will execute the tar command as root. Because of the way it is written, it will grab everything inside the /var/www/html and interpret our fake files as options.</p>\n<p><img src=\"https://i.imgur.com/xJdgaxh.png\" alt=\"\" width=\"967\" height=\"92\" /></p>\n<p>Now let's wait until the next minute and then:</p>\n<p style=\"padding-left: 30px;\">$ sudo bash</p>\n<p><img src=\"https://i.imgur.com/Hw169Np.png\" alt=\"\" width=\"397\" height=\"56\" /></p>\n<p>We are not asked to type any password and now we are root!</p>\n<p><input id=\"toctogglecheckbox\" class=\"toctogglecheckbox\" style=\"display: none;\" type=\"checkbox\" /></p>","readme":"","difficulty":"Advanced","author":"NS"}
