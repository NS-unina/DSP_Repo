{"description":"Sniff and analyze HTTP traffic using Wireshark","goal":"<p>Open&nbsp;<a href=\"https://{{hostname}}:14500/?username=wireshark&amp;password=wireshark\" target=\"_blank\" rel=\"noopener noreferrer\">https://{{hostname}}:14500/?username=wireshark&amp;password=wireshark</a>&nbsp; inside the browser and start sniffing.</p>\n<p>&nbsp;</p>","solution":"<p>In this lab, we'll use Wireshark to sniff, analyze and therefore investigate the fundamentals of the HTTP protocol.</p>\n<h2>Basic HTTP Get/response interaction</h2>\n<p>Open&nbsp;<a href=\"https://{{hostname}}:14500/?username=wireshark=password=wireshark\" target=\"_blank\" rel=\"noopener noreferrer\">https://{{hostname}}:14500/?username=wireshark&amp;password=wireshark</a> &nbsp; inside the browser.</p>\n<p>Start up the packet sniffing, click on \"eth0\" and enter \"http\" in the display-filter-specification window, so that only HTTP messages will be displayed.</p>\n<p>&nbsp;</p>\n<p>Now access wireshark container's command line and type</p>\n<pre style=\"padding-left: 30px;\">$ curl <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html</a></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>You'll get as a response a very simple one-line HTML file.</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/Get.png\" alt=\"\" width=\"823\" height=\"98\" /></p>\n<p>Wireshark's interface shows two HTTP messages. If you click on each packet, the window below will show details about the HTTP message, as long as other protocols in the ISO/OSI stack used to carry the packets.</p>\n<p>Taking a closer look to both the request and the response messages, we discover the protocol version supported (HTTP 1.1 both for the User-Agent and the server) and their respective IP-addresses.</p>\n<p>Focusing on the response, try to find the following information:</p>\n<ul>\n<li>The status code returned from the server;</li>\n<li>When was the HTML file last modified at the server;</li>\n<li>The number of bytes of content exchanged.</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/wireshark_get.png\" alt=\"\" width=\"652\" height=\"600\" />&nbsp;</p>\n<h2>HTTP Conditional GET</h2>\n<p>If you try performing the same request in a browser, you'll notice, in the network section of the browser console, that a usual GET request contains more headers then simply those we have seen inspecting our Curl requests.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/conditional_browser.png\" alt=\"\" width=\"888\" height=\"504\" /></p>\n<p>In particular, because most web browsers perform object caching, when retreiving an HTTP object they tend to include the \"If-Modified-Since\" Header, thus performing a conditional GET request. The server will respond with a</p>\n<p>new version of the file requested, only if it has been modified since the date provided in the request, otherwise will send an HTTP response with status code 304 and without a body.</p>\n<p>Let's check this out in our wireshark container, entering (remember to restart the packet sniffing in wireshark) :</p>\n<pre style=\"padding-left: 30px;\">$ curl <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file2.html</a></pre>\n<p style=\"padding-left: 30px;\">Now take the value of the response's Header Field \"Last-Modified\" and modify the next URL (in place of &lt;value&gt;)</p>\n<pre style=\"padding-left: 30px;\">$ curl --header 'If-Modified-Since:&lt;value&gt;' <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file2.html</a></pre>\n<p>Looking at the packets details, can you tell the status code and the phrase returned? And how can you tell if the server actually returned the contents of the file or not?</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/conditional_wireshark.png\" alt=\"\" width=\"928\" height=\"611\" /></p>\n<h2>Retreiving Long Documents</h2>\n<p>So far we've only retreived short HTML files. Try now to get the following file. Stop and restart the capture in wireshark, in order to display only the packets captured in this very session.</p>\n<pre style=\"padding-left: 30px;\">$ curl <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file3.html</a></pre>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/Long_bash.png\" alt=\"\" width=\"920\" height=\"522\" /></p>\n<p>As you can see, a rather long HTML file is received.</p>\n<p>If you check the wireshark webpage, there is only one GET request message, but if you click on the response message, in the window below a new table shows up, saying \"Reassembled TCP\".</p>\n<p>What happened is that, because the HTML file is rather long, it didn't fit in a single TCP packet, so it was broken in several TCP segments, which were correctly reassembled once received.</p>\n<p>This way you can see the whole HTTP response, containing the long body.</p>\n<p>If you now remove the \"http\" filter, you can actually see the sequence of TCP segments exchanged between the HTTP GET request and the response</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/long_wireshark.png\" alt=\"\" width=\"909\" height=\"605\" />&nbsp;</p>\n<p>By looking at the length of the segments exchanged, can you infer the maximum length of each segment? Which protocol forces packets to have a precise byte-length upper bound?</p>\n<h2>HTML Documents with Embedded Objects</h2>\n<p>If you try getting the next file in a browser, by following the URL <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file4.html</a></p>\n<p>a simple HTML file with two images will be displayed.</p>\n<p>However, the images are not embedded in the HTML; instead, only the URLs for the images are listed in the HTML code, indicating that they're stored elsewhere, potentially on a completely different host.</p>\n<p>We'll use wget now, which allows for a recursive retreival, which means that we'll be able to follow the URLs embedded in the webpage and retreive the images as well.</p>\n<p>Stop and restart the capture and type the following string in the command line</p>\n<pre style=\"padding-left: 30px;\">$ wget -r <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file4.html\">http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file4.html</a></pre>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/embedded_wget.png\" alt=\"\" width=\"817\" height=\"464\" /></p>\n<p>In wireshark you can notice that, even though we only performed one single GET request, in order to get all the content and display it the right way, at least two more GET requests needed to be done.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/embedded_wireshark.png\" alt=\"\" width=\"933\" height=\"623\" />&nbsp;</p>\n<h2>HTTP Basic Authentication</h2>\n<p>Now let's try access a webpage in a protected area on the server. Remember to stop and restart the capture.</p>\n<p>If you try accessing it in your browser by following the URL <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/protected_pages/HTTP-wireshark-file5.html</a></p>\n<p>a window asking for credentials pops up</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/pop_up.png\" alt=\"\" width=\"792\" height=\"244\" /></p>\n<p>If you type in the username: \"myuser\" and the password: \"user\", the page you are requesting is correctly displayed.</p>\n<p>Let's riproduce the steps using the command line.</p>\n<pre style=\"padding-left: 30px;\">$ curl <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/protected_pages/HTTP-wireshark-file5.html</a></pre>\n<p>We get the following output from the command line:</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/basic_get.png\" alt=\"\" width=\"973\" height=\"271\" /></p>\n<p>Now we use the curl \"-u\" option to specify credentials for authentication</p>\n<pre style=\"padding-left: 30px;\">$ curl -u myuser:user <a href=\"http://193.21.1.4:80/wireshark-lab/HTTP-wireshark-file1.html\">http://193.21.1.4:80/wireshark-lab/protected_pages/HTTP-wireshark-file5.html</a></pre>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/basic_get_pwd.png\" alt=\"\" width=\"953\" height=\"76\" /></p>\n<p>In wireshark we can notice two get requests with different status code responses. The difference between the two GET requests stands in one single header which is added in the second message. Can you tell which header?</p>\n<p>Take a look at the second GET request</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L00_WiresharkLabHTTP/.images/wireshark_basic.png\" alt=\"\" width=\"869\" height=\"610\" /></p>\n<p>The new header we are looking for is \"Authorization: Basic\", followed by what seems to be an encrypted version of username and password. Unfortunately, they are not! Username and password in HTTP basic authentication are</p>\n<p>simply encoded in a format known as \"Base64\". In fact, you can go to <a href=\"http://www.motobit.com/util/base64-decoder-encoder.asp\">http://www.motobit.com/util/base64-decoder-encoder.asp</a>, enter the base64-encoded string and Voila! You get your username and password.</p>\n<p>Since tools like Wireshark and Base64 decoder are available to anyone, it seems clear that simple passwords on websites are not secure unless additional measures are taken.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3>&nbsp;</h3>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","readme":"","difficulty":"Medium","author":"NS"}
