{"description":"Linux Privilege Escalation Using PATH Variable","goal":"<p>Explore various methods to escalate privileges on a linux machine exploiting misconfigurations of permissions using the PATH environment variable</p>\n<p>This Lab was modeled after the following article:&nbsp;<a href=\"https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/\">https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/</a></p>","solution":"<p>First off, if you do not already have it, go ahead and grab our lightweight ssh client hack tool. <br />In a terminal on your host, type:</p>\n<p style=\"padding-left: 30px;\">$ docker pull nsunina/alpine_ssh:latest</p>\n<p>&nbsp;</p>\n<p>Start the lab and follow the standard procedure to attach an interactive hack tool. This will allow you to interact with the vulnerable environment.</p>\n<p>Create a new interactive service in the Hack Tool tab: name it \"ssh_client\", select \"nsunina/alpine_ssh:latest\" as base docker image and run it.</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/1.png\" alt=\"\" width=\"1367\" height=\"626\" /></p>\n<p>As soon as the container is up and running, attach it to the target network:</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/2.png\" alt=\"\" width=\"425\" height=\"123\" /></p>\n<p>Then, access the web shell.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/3.png\" alt=\"\" width=\"277\" height=\"112\" /></p>\n<p>Connect to the vulnerable container via SSH as an unprivileged user. In reality, you will have to compromise the target machine and get remote access, before applying any of the following techniques.</p>\n<p style=\"padding-left: 30px;\">$ ssh <a href=\"mailto:user1@193.20.1.2\">user1@193.20.1.2</a></p>\n<p>The password is \"pass123\".</p>\n<h3>&nbsp;PATH environment variable</h3>\n<p>An environment variable is by all means like any other variable: a named object that contains data. However, instead of living inside the scope of a function, or an entire module of a complex program, it shares its values with other applications. The \"environment\" scope is usually the one of the Operating System. It provides an efficient way to share settings among separate processes. It can be defined globally, per user or per session. For further information, check the archlinux docs:</p>\n<p><a href=\"https://wiki.archlinux.org/index.php/Environment_variables\">https://wiki.archlinux.org/index.php/Environment_variables</a></p>\n<p>The PATH variable is a very common one in both Linux and Windows systems. It stores the location of all executable files in the file system. It is useful when the user calls an utility program, for instance from a terminal: the OS checks whether the corresponding executable file is present in one of the folders included in the PATH.</p>\n<p>We can check the current value of the PATH variable in our running container. Type:</p>\n<p style=\"padding-left: 30px;\">$ echo $PATH</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/4.png\" alt=\"\" width=\"592\" height=\"37\" /></p>\n<p>As you can see, paths are separated by the colon character.</p>\n<p>&nbsp;</p>\n<h3>Privilege Escalation</h3>\n<p>One of the first things that the penetration tester does, after compromising the target, is to look for files where the \"setuid\" bit is set.</p>\n<p>For further information about the SUID bit and the corresponding privilege escalation technique, we have a specific lab for that; check it out!</p>\n<p>Using the linux \"find\" utility, we can search for all the files with the SUID bit set to 1:</p>\n<div class=\"crayon-pre\" style=\"font-size: 14px !important; line-height: 17px !important; -moz-tab-size: 4; -o-tab-size: 4; -webkit-tab-size: 4; tab-size: 4;\">\n<div id=\"crayon-5ed78d1c8ef92696275981-1\" class=\"crayon-line\" style=\"padding-left: 30px;\"><span class=\"crayon-v\">$ find</span> <span class=\"crayon-o\">/</span> <span class=\"crayon-o\">-</span><span class=\"crayon-v\">perm</span> <span class=\"crayon-o\">-</span><span class=\"crayon-v\">u</span><span class=\"crayon-o\">=</span><span class=\"crayon-v\">s</span> <span class=\"crayon-o\">-</span><span class=\"crayon-i\">type</span> <span class=\"crayon-i\">f</span> <span class=\"crayon-cn\">2</span><span class=\"crayon-o\">&gt;</span><span class=\"crayon-o\">/</span><span class=\"crayon-v\">dev</span><span class=\"crayon-o\">/</span><span class=\"crayon-t\">null</span></div>\n<div class=\"crayon-line\" style=\"padding-left: 30px;\">&nbsp;</div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">which literally means \"find, starting from the root folder, files that users are allowed to execute as they were owners and redirect the stderr to the linux file /dev/null\".</span></div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\">&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/5.png\" alt=\"\" width=\"491\" height=\"252\" /></div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">Besides some standard linux utilities which usually run as superuser, there are 4 binaries in the script folder that have the bit suid. Let's go check them out.</span></div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">List all files inside the /script directory:</span></div>\n<div class=\"crayon-line\" style=\"padding-left: 30px;\">&nbsp;</div>\n<div class=\"crayon-line\" style=\"padding-left: 30px;\"><span class=\"crayon-t\">$ ls -la /script</span></div>\n<div class=\"crayon-line\" style=\"padding-left: 30px;\">&nbsp;</div>\n<div class=\"crayon-line\">&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/6.png\" alt=\"\" width=\"473\" height=\"150\" /></div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">As you can see, the owner of the files is \"root\" and the bit suid is set for the user. We got ourselves a treat!</span></div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">Let's try and execute these binaries and see what happens.</span></div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\"><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/7.png\" alt=\"\" width=\"373\" height=\"95\" /></div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">We see a list of running programs. This seems to be the output of the \"ps\" command.</span></div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">So far we know that we can execute as root a program that runs the linux ps utility. </span></div>\n<div class=\"crayon-line\"><span class=\"crayon-t\">There is a chance that the utility \"ps\" is called using the PATH variable: when the \"shell\" program is called, the OS sees that it calls the \"ps\" utility, so it goes through the paths specified in the PATH variable to look for a program called \"ps\". It finds one in the bin directory. What happens if we modify the PATH variable and tell the OS to go check first in a directory specified by us? We might be able to trick the OS in calling our own version of \"ps\". </span></div>\n<h4 class=\"crayon-line\"><span class=\"crayon-t\">Our PS utility</span></h4>\n<p><span class=\"crayon-t\">Let's write our own version of \"ps\" in the /tmp directory. Remember that, because the \"shell\" file has the SUID bit set, we will execute our own \"ps\" program as if we were root. So, of course, we are going to put a shell inside it!</span></p>\n<p style=\"padding-left: 30px;\"><span class=\"crayon-t\">$ echo \"/bin/bash\" &gt; /tmp/ps</span></p>\n<p><span class=\"crayon-t\">Let's also remember to give the script the right permissions.</span></p>\n<p style=\"padding-left: 30px;\"><span class=\"crayon-t\">$ chmod 777 /tmp/ps</span></p>\n<p><span class=\"crayon-t\">Now, the only thing left to do, is modify the PATH variable and include the /tmp directory. We want the OS to look first in the directory where our version of \"ps\" is and ignore the one located in the /bin directory. So, we will add the \"/tmp\" directory at the begininning of the PATH variable.</span></p>\n<p><span class=\"crayon-t\">The \"export\" command, allows to modify the value of an environment variable and update it for the current user at the same time.</span></p>\n<p style=\"padding-left: 30px;\"><span class=\"crayon-t\">$ export PATH=/tmp:$PATH</span></p>\n<p><span class=\"crayon-t\">Now let's execute the \"shell\" program and see if our trick worked</span></p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/11.png\" alt=\"\" width=\"351\" height=\"56\" /></p>\n<p><span class=\"crayon-t\">We are root!</span></p>\n<h4><span class=\"crayon-t\">Text editors</span></h4>\n<p><span class=\"crayon-t\">We used echo to write our own \"ps\". Remember that you can use any other editor available to the user, such as vim or nano, to create your own executables.</span></p>\n<h3><span class=\"crayon-t\">Other binaries</span></h3>\n<p><span class=\"crayon-t\">There are other binaries with the suid bit set inside the /script folder. Execute them and try to figure out what they do. Apply the same technique described before and escalate the privileges.</span></p>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\">&nbsp;</div>\n<div class=\"crayon-line\">&nbsp;</div>\n</div>\n<p>&nbsp;</p>","readme":"","difficulty":"Medium","author":"NS"}
