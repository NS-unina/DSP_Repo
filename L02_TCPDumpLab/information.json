{"description":"A fun TCP recap with a hands-on hacker approach.","goal":"<p>Take a quick TCP reminder lesson while performing some simple attacks.</p>","solution":"<h3>TCP(dump) Lab</h3>\n<p>We have a local network with a telnet client and a few hacking tools, such as Kali Linux and Scapy. A router in the middle separates the local network from an external one with a telnet server.</p>\n<p>The router firewalling rules will allow for the forwarding of telnet traffic from the client to the server, but others won't be able to capture traffic flowing between them.</p>\n<p>Telnet works with TCP protocol, so it would be useful to sniff some traffic to try and understand what's going on.</p>\n<p>Easy, let's perform a man in the middle attack.</p>\n<h3>MITM Attack</h3>\n<p>In order to capture the traffic flowing in both directions between client and server, we need to make the router believe that we are the victim (telnet client) and the victim that we are the router.</p>\n<p>The Kali machine is engaged with the tool \"arpspoof\" which lets us performing an ARP spoofing:</p>\n<p>we constantly send the victim ARP answers telling him that the MAC address belonging to the IP of the gateway machine (router) is our MAC address. After some time the victim computer will believe us and makes a wrong entry in his ARP cache. Next time the victim wants to send an IP packet to the gateway, he sends the ethernet frame to our MAC address. We do the same thing with the gateway machine just the other way around.</p>\n<p>With the next command we fool the victim and announce the router's IP address to be associated to our MAC</p>\n<pre style=\"padding-left: 30px;\">$ arpspoof -i eth0 -t 192.168.2.4 192.168.2.2 2&gt; /dev/null &amp;</pre>\n<p>The next command does the opposite</p>\n<pre style=\"padding-left: 30px;\">$ arpspoof -i eth0 -t 192.168.2.2 192.168.2.4 2&gt; /dev/null &amp;</pre>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/mitm.png\" alt=\"\" width=\"725\" height=\"73\" /></p>\n<p>Notice that the syntax of the arpspoof command requires you to first type the victim's IP address and then the one of the host that we are impersonating.</p>\n<p>By typing \"2&gt; /dev/null &amp;\" at the end of the line, we make sure no output is shown on our console and the program is running in background, so we can launch both commands on the same terminal window.</p>\n<p>Now we should be able to capture traffic flowing between the two hosts.</p>\n<pre style=\"padding-left: 30px;\">$ tcpdump -i eth0 -A -n tcp -S</pre>\n<p>With the last command we are telling tcpdump to capture incoming TCP traffic on interface \"eth0\" and to print each packet in ASCII (-A option), without translating IP addresses (-n option).</p>\n<p>By default, tcpdump will print Sequence and Acknowledgment numbers relative to each TCP connection. With the \"-S\" option we tell tcpdump to display absolute seq and ack numbers.</p>\n<p>For the purposes of this lab, we are impersonating both attacker and victim, so let's access the telnet client container and estabilish a connection with the telnet server</p>\n<pre style=\"padding-left: 30px;\">$ telnet 192.168.1.3</pre>\n<p>The credentials are:&nbsp;</p>\n<p><em>login name</em>: <strong>jack</strong></p>\n<p><em>Password</em>: <strong>MyPasswordALittleComplex&nbsp;</strong></p>\n<p>Now, on our Kali Machine we see the TCP traffic flowing between the two hosts.</p>\n<h4>Three-Way Handshake</h4>\n<p>First thing to be noticed is the three-way handshake, in other words TCP way to estabilish a connection.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/3-way.png\" alt=\"\" width=\"1740\" height=\"324\" />&nbsp;</p>\n<ol>\n<li>The first segment is referred to as SYN segment, because a flag called \"SYN\" is set in the TCP header. On this occasion, the client randomly chooses a sequence number;</li>\n<li>Once the SYN segment has been received on the server side, the server allocates variables and buffers associated to the connection, sets the SYN flag to 1, chooses its own sequence number and sets the ack to client_isn + 1. This message is referred to as SYNACK segment. The reason why the server sends a personal sequence number as well is that the TCP connection is full-duplex, so data can be flowing both ways at the same time and both client and server rely on the sqn/ack mechanism to ensure a reliable transmission;</li>\n<li>Upon receiving the SYNACK segment, the client also allocates buffers and variables and sends a last ACK segment setting the acknoledgement number field to server_isn + 1.</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/3-way_kurose.png\" alt=\"\" width=\"739\" height=\"641\" /></p>\n<p>&nbsp;</p>\n<h3>RESET Attack</h3>\n<p>There are two ways to finalize a TCP connection. One involves the exchange of FIN segments both sides, followed by respective acknowledgements. The other, the less polite one, involves the setting of the RST flag, which tells the receiver to abandon the connection immediately.</p>\n<p>An attacker can use this protocol feature to close a legitimate connection between two hosts.</p>\n<p>In order to do that, we have to be able to correctly craft a TCP packet and guess those sequence numbers not already acknowledged.</p>\n<p>Rimember that:</p>\n<p><em>A sequence number is the byte-stream number of the first byte in the segment, while the acknowledgment number is the sequence number of the next byte coming from the other host.<br /></em></p>\n<p><em>The acknowledgment number tells the number of the first byte that has not been received yet.</em></p>\n<p>Let's take a look at the last connection between host \"192.168.2.4\" and host \"192.168.1.3\", one when they have both sent some data.</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/last.png\" alt=\"\" width=\"1647\" height=\"326\" /></p>\n<p>If we want to make the client (\"192.168.2.4\") believe that the server (\"192.168.1.3\") wants to close the connection with a RST packet, we need to imagine the next exchange of data from server to client.</p>\n<p>First, we need to acknowledge the last amount of data received from the client: we take the last sequence number coming from \"192.168.2.4\" and sum the number of bytes of the payload. Fortunately, tcpdump in its latest versions already calculates this value, after the colon (\":\"). In this case the next ACK number would be \"2401310867\".</p>\n<p>The next sequence number would be the last one sent from the server, plus the number of bytes of payload sent from server to client in the last communication, or, if you prefer, the last acknowledgement number sent from the client. Tcpdump calculates this value as well, the one on the top of the figure, after the colon: \"3864234800\".</p>\n<p>Now we are ready to go. Let's open the scapy console and type</p>\n<pre style=\"padding-left: 30px;\">$ scapy</pre>\n<p>This utlity will allow us to craft a packet as we desire.</p>\n<p style=\"padding-left: 30px;\">The information we need are</p>\n<pre style=\"padding-left: 30px;\">i = IP()<br /><br />t = TCP()<br /><br />i.dst = \"192.168.2.4\"<br /><br />i.src = \"192.168.1.3\"<br /><br />t.sport = 23<br /><br />t.dport = 47362<br /><br />t.flags = \"RA\"<br /><br />t.ack = 2401310867<br /><br />t.seq = 3864234800<br /><br />t.window = 0<br /><br />send(i/t)</pre>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/scapy.png\" alt=\"\" width=\"272\" height=\"241\" /></p>\n<p>After we sent the packet, we can check the console of the telnet clientand discover that the connection as been closed.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/telnet_reset.png\" alt=\"\" width=\"468\" height=\"225\" /></p>\n<p>We can also check the output of tcpdump and see the RST packet captured.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L02_TCPDumpLab/.images/reset_tcpdump.png\" alt=\"\" width=\"878\" height=\"76\" /></p>\n<p>Owned!</p>\n<p style=\"margin: 0px; font-size: 12px; line-height: normal; font-family: 'Helvetica Neue'; color: #454545; padding-left: 30px;\">&nbsp;</p>","readme":"","difficulty":"Medium","author":"NS"}
