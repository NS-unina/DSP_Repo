{"description":"Privilege escalation using LD_PRELOAD environment variable","goal":"<p>Explore various methods to escalate privileges on a linux machine using LD_PRELOAD environment variable</p>\n<p>This Lab was modeled after the following article:&nbsp;<a href=\"https://www.hackingarticles.in/linux-privilege-escalation-using-ld_preload/\">https://www.hackingarticles.in/linux-privilege-escalation-using-ld_preload/</a></p>","solution":"<p>First off, if you do not already have it, go ahead and grab our lightweight ssh client hack tool. <br />In a terminal on your host, type:</p>\n<p style=\"padding-left: 30px;\">$ docker pull nsunina/alpine_ssh:latest</p>\n<p>&nbsp;</p>\n<p>Start the lab and follow the standard procedure to attach an interactive hack tool. This will allow you to interact with the vulnerable environment.</p>\n<p>Create a new interactive service in the Hack Tool tab: name it \"ssh_client\", select \"nsunina/alpine_ssh:latest\" as base docker image and run it.</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/1.png\" alt=\"\" width=\"1367\" height=\"626\" /></p>\n<p>As soon as the container is up and running, attach it to the target network:</p>\n<p>&nbsp;<img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/2.png\" alt=\"\" width=\"425\" height=\"123\" /></p>\n<p>Then, access the web shell.</p>\n<p><img src=\"https://raw.githubusercontent.com/NS-unina/DSP_Repo/master/L_EXTRA_PrivilegeEscalation_PATH/.images/3.png\" alt=\"\" width=\"277\" height=\"112\" /></p>\n<p>Connect to the vulnerable container via SSH as an unprivileged user. In reality, you will have to compromise the target machine and get remote access, before applying any of the following techniques.</p>\n<p style=\"padding-left: 30px;\">$ ssh <a href=\"mailto:user1@193.20.1.2\">user1@193.20.1.2</a></p>\n<p>The password is \"pass123\".</p>\n<h3>LD_PRELOAD environment variable</h3>\n<p>LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</p>\n<p>Remember that a shared library is a file containing object code that several <em>a.out</em> files may use simultaneously while executing. When a program is link edited with a shared library, the library code that defines the program's external references is not copied into the program's object file. Instead, a special section called <strong>.lib</strong> that identifies the library code is created in the object file. When the UNIX system executes the resulting <em>a.out</em> file, it uses the information in this section to bring the required shared library code into the address space of the process.</p>\n<p>When the LD_PRELOAD is used in combination with a program executed with higher privileges, we can create our own shared library and make it run in the context of the administrator.</p>\n<h3>Privilege Escalation</h3>\n<p>First thing, after logging into the target system, we can check, as usual, whether our user1 is a sudoer or not</p>\n<p style=\"padding-left: 30px;\">$ sudo -l</p>\n<p><img src=\"https://i.imgur.com/wqqVQ0a.png\" alt=\"\" width=\"1613\" height=\"135\" /></p>\n<p>We can run the linux \"find\" utility as root without password, but, with it alone, we can not do much.</p>\n<p>However, the string \"env_keep+=LD_PRELOAD\" tells us that we can preload some shared libraries to executable files.</p>\n<p>How about writing a shared library that runs a shell and then link it to /usr/bin/find? This way, the nasty code inside the shared library will be executed in the context of the administrator user.</p>\n<p>Let's move into an usually writable directory, such as /tmp.</p>\n<p>We can use vim, but also remember this useful trick to write small files directly on the terminal.</p>\n<p><img src=\"https://i.imgur.com/3BTPxtT.png\" alt=\"\" width=\"529\" height=\"280\" /></p>\n<p>Now we can compile it and produce a shared library with the following command:</p>\n<p style=\"padding-left: 30px;\">$ gcc -fPIC -shared -o shell.so shell.c -nostartfiles</p>\n<p>Last thing to do, is to call /usr/bin/find and link our shared library via LD_PRELOAD environment variable.</p>\n<p style=\"padding-left: 30px;\">$ sudo LD_PRELOAD=./shell.so find</p>\n<p><img src=\"https://i.imgur.com/s05xLWr.png\" alt=\"\" width=\"650\" height=\"68\" /></p>\n<p>Voil&agrave;!</p>","readme":"","difficulty":"Medium","author":"NS"}
